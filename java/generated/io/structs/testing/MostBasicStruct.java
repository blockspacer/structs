// @generated: This file is autogenerated by the Structs compiler, DO NOT EDIT MANUALLY

package io.structs.testing;

import com.datastax.driver.core.BoundStatement;
import com.datastax.driver.core.PreparedStatement;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.ResultSetFuture;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Session;

public final class MostBasicStruct {
  public enum Fields {
    ID("id");

    public final String fieldName;

    Fields(String fieldName) {
      this.fieldName = fieldName;
    }

    public static Iterable<Fields> all() {
      com.google.common.collect.ImmutableList.Builder<Fields> b = com.google.common.collect.ImmutableList.builder();
      b.add(ID);
      return b.build();
    }
  }

  private final Session session;
  private final com.google.common.base.Supplier<PreparedStatement> selectAllStmt;
  private final com.google.common.base.Supplier<PreparedStatement> insertAllStmt;

  public MostBasicStruct(Session session) {
    this.session = session;
    this.selectAllStmt = com.google.common.base.Suppliers.memoize(() -> {
      return createSelectAllStmt(session);
    });

    this.insertAllStmt = com.google.common.base.Suppliers.memoize(() -> {
      return createInsertAllStmt(session);
    });
  }

  private static PreparedStatement createSelectAllStmt(Session session) {
    Iterable<String> names = com.google.common.collect.Iterables.transform(Fields.all(), x -> x.fieldName);
    StringBuilder sb = new StringBuilder("select ");
    com.google.common.base.Joiner.on(',').appendTo(sb, names);
    sb.append(" from most_basics where id=?");
    return session.prepare(sb.toString());
  }

  public java.util.Optional<io.structs.testing.TestingProto.MostBasic> load(String id) {
    PreparedStatement stmt = selectAllStmt.get();
    BoundStatement bound = stmt.bind(id);
    ResultSet rs = session.execute(bound);
    Row row = rs.one();
    if (row == null) {
      return java.util.Optional.empty();
    }

    return java.util.Optional.of(ofRowOrDie(row));
  }

  public com.google.common.util.concurrent.ListenableFuture<java.util.Optional<io.structs.testing.TestingProto.MostBasic>> loadAsync(String id) {
    PreparedStatement stmt = selectAllStmt.get();
    BoundStatement bound = stmt.bind(id);
    ResultSetFuture rsF = session.executeAsync(bound);
    return com.google.common.util.concurrent.Futures.transform(rsF, rs -> {
      Row row = rs.one();
      if (row == null) {
        return java.util.Optional.empty();
      }

      return java.util.Optional.of(ofRowOrDie(row));
    });
  }

  private static io.structs.testing.TestingProto.MostBasic ofRowOrDie(Row row) {
    try {
      return ofRow(row);
    } catch (com.google.protobuf.InvalidProtocolBufferException ex) {
      throw io.grpc.Status.fromThrowable(ex).asRuntimeException();
    }
  }

  private static io.structs.testing.TestingProto.MostBasic ofRow(Row row) throws com.google.protobuf.InvalidProtocolBufferException {
    io.structs.testing.TestingProto.MostBasic.Builder b = io.structs.testing.TestingProto.MostBasic.newBuilder();

    {
      int idx = row.getColumnDefinitions().getIndexOf("id");
      if (!row.isNull(idx)) {
        String value = row.getString(idx);
        b.setId(value);
      }
    }

    
    return b.build();
  }

  private static PreparedStatement createInsertAllStmt(Session session) {
    StringBuilder sb = new StringBuilder();
    sb.append("INSERT INTO most_basics (");
    sb.append("id) ");
    sb.append("VALUES (?)");

    return session.prepare(sb.toString());
  }

  public void save(io.structs.testing.TestingProto.MostBasic obj) {
    PreparedStatement stmt = insertAllStmt.get();
    Object[] boundObjs = new Object[1];

    {
      Object o = null;
      o = obj.getId();
      boundObjs[0] = o;
    }

    BoundStatement bound = stmt.bind(boundObjs);
    session.execute(bound);
  }

  public com.google.common.util.concurrent.ListenableFuture<Void> saveAsync(io.structs.testing.TestingProto.MostBasic obj) {
    PreparedStatement stmt = insertAllStmt.get();
    Object[] boundObjs = new Object[1];

    {
      Object o = null;
      o = obj.getId();
      boundObjs[0] = o;
    }

    BoundStatement bound = stmt.bind(boundObjs);
    ResultSetFuture rsF = session.executeAsync(bound);
    return com.google.common.util.concurrent.Futures.transform(rsF, x -> null);
  }
}
